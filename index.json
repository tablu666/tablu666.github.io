[{"categories":["project"],"content":"Online shopping mall, Java 8, REST API.","date":"2022-04-16","objectID":"/springboot-vue-online-mall/","tags":["technique","web"],"title":"Spring Boot \u0026 Vue Online mall","uri":"/springboot-vue-online-mall/"},{"categories":["project"],"content":"E-commerce website ","date":"2022-04-16","objectID":"/springboot-vue-online-mall/:0:0","tags":["technique","web"],"title":"Spring Boot \u0026 Vue Online mall","uri":"/springboot-vue-online-mall/"},{"categories":["project"],"content":"Intro A full-stack web application using Spring boot and Vue Cli. This is an online shopping application with frontend and backend separated which is mainly developed for consumers, it also includes simple order \u0026 user management backend services. The frontend calls the backend API and performs data interaction through JSON. Live Demo: https://tvmall-tablu.herokuapp.com/ ","date":"2022-04-16","objectID":"/springboot-vue-online-mall/:1:0","tags":["technique","web"],"title":"Spring Boot \u0026 Vue Online mall","uri":"/springboot-vue-online-mall/"},{"categories":["project"],"content":"Screenshot ","date":"2022-04-16","objectID":"/springboot-vue-online-mall/:2:0","tags":["technique","web"],"title":"Spring Boot \u0026 Vue Online mall","uri":"/springboot-vue-online-mall/"},{"categories":["project"],"content":"Features REST API Full JSON interaction Redis-based shopping cart Order process Categories Pagination ","date":"2022-04-16","objectID":"/springboot-vue-online-mall/:3:0","tags":["technique","web"],"title":"Spring Boot \u0026 Vue Online mall","uri":"/springboot-vue-online-mall/"},{"categories":["project"],"content":"Technology Stacks Backend Java 8 Spring Boot 2.1.7 Mybatis MySQL Redis Spring Security Maven Frontend Vue CLI 4.5.4 ","date":"2022-04-16","objectID":"/springboot-vue-online-mall/:4:0","tags":["technique","web"],"title":"Spring Boot \u0026 Vue Online mall","uri":"/springboot-vue-online-mall/"},{"categories":["project"],"content":"Database Schema ","date":"2022-04-16","objectID":"/springboot-vue-online-mall/:5:0","tags":["technique","web"],"title":"Spring Boot \u0026 Vue Online mall","uri":"/springboot-vue-online-mall/"},{"categories":["project"],"content":"Rapid deployment \u0026 Run Backend Install MySQL Create a local database like ‚Äòmall‚Äô using MySQL Workbench or Navicat Execute SQL statement to build table. (cd backend/src/main/resources/sql) Prepare Redis Configure spring datasource \u0026 Redis in application.yml The server is running on localhost:8080 Frontend Install Node.js and npm cd frontend Run npm install Run npm run serve The client is running on localhost:8081 Note: it only works locally, some codes should be modified before production mode. ","date":"2022-04-16","objectID":"/springboot-vue-online-mall/:6:0","tags":["technique","web"],"title":"Spring Boot \u0026 Vue Online mall","uri":"/springboot-vue-online-mall/"},{"categories":["algorithm"],"content":"Double pointer algorithm.","date":"2022-04-16","objectID":"/double-pointer/","tags":["leetcode"],"title":"Double Pointer Algorithm","uri":"/double-pointer/"},{"categories":["algorithm"],"content":"Double Pointer Problems According to CS-Notes, I want to share some thoughts about 6 common double pointer problems on Leetcode. ","date":"2022-04-16","objectID":"/double-pointer/:1:0","tags":["leetcode"],"title":"Double Pointer Algorithm","uri":"/double-pointer/"},{"categories":["algorithm"],"content":"Sorted Array - Two Sum 167. Two Sum II - Input array is sorted (Easy) Problem: Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Solution: Having done this before, the first thing that came to mind was to iterate over the array, storing each value and its index into a HashMap, and then iterate over the array again, looking for the existence of (target- current value) in the dictionary. class Solution { public int[] twoSum(int[] numbers, int target) { HashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); int[] temp = new int[2]; for(int i = 0; i \u003c numbers.length; i++) { map.put(numbers[i], i); } for(int i = 0; i \u003c numbers.length; i++) { if(map.containsKey(target- numbers[i])) { int index1 = i; int index2 = map.get(target- numbers[i]); temp[0] = index1 + 1; temp[1] = index2 + 1; return temp; } } return temp; } } It turns out that we could use double pointer algorithm to solve this problem. The idea is very simple. As the topic said, only unique solutions, there must be a sum of two numbers equals to target in the array. We could arrange one pointer at the head and the other at the tail, pointing to minimum and maximum respectively. By judging the difference between the sum of two numbers and the target value, we could easilty tune the maximum value or minimum, ensuring that getting the answer with at most one iteration, and the space complexity is reduced from O (N) to O (1). class Solution { public int[] twoSum(int[] numbers, int target) { int min = 0; int max = numbers.length - 1; while ((numbers[min] + numbers[max]) != target) { if ((numbers[min] + numbers[max]) \u003c target) { min++; } else { max--; } } int[] res = new int[]{min + 1, max + 1}; return res; } } ","date":"2022-04-16","objectID":"/double-pointer/:1:1","tags":["leetcode"],"title":"Double Pointer Algorithm","uri":"/double-pointer/"},{"categories":["algorithm"],"content":"Two Sum Square 633. Sum of Square Numbers (Easy) Problem Given a non-negative integer c, your task is to decide whether there‚Äôre two integers a and b such that $a^2+b^2=c$. Example: Input: 5 Output: True Explanation: $1\\times1+2\\times2=5$ Solution I couldn‚Äôt believe that we could use double pointer algorithm in this problem. After seeing the solution, I would say it is incredible! The idea is that one pointer points to 0 and the other pointer points to the square root of the input value (taking the integer part). This ensures that the minimum and maximum values cover all the integer values in the input, and then narrowing the range is enough. class Solution { public boolean judgeSquareSum(int c) { int min = 0; int max = (int) Math.sqrt(c); while (min \u003c= max) { int sum = min * min + max * max; if (sum \u003c c) { min++; } else if (sum \u003e c) { max--; } else { return true; } } return false; } } ","date":"2022-04-16","objectID":"/double-pointer/:1:2","tags":["leetcode"],"title":"Double Pointer Algorithm","uri":"/double-pointer/"},{"categories":["algorithm"],"content":"Reverse Vowels 345. Reverse Vowels of a String (Easy) Problem Write a function that takes a string as input and reverse only the vowels of a string. Example Input: ‚Äúhello‚Äù Output: ‚Äúholle‚Äù Solution This problem is also very interesting, using two pointers perfectly solved (head and tail + judging the vowel + exchange), the only thing to pay attention to is the vowel ‚ÄúAEIOU‚Äù contains big lowercase! No wonder thumbs down üëé more than up üëç! class Solution { public String reverseVowels(String input) { if (input == null || input.equals(\"\")) { return input; } char[] chars = input.toCharArray(); Set\u003cCharacter\u003e set = new HashSet\u003cCharacter\u003e(Arrays.asList('a','e','i','o','u','A','E','I','O','U')); int s = 0; int e = input.length() - 1; while (s \u003c e) { char start = chars[s]; char end = chars[e]; if (!set.contains(start)) { s++; } else if (!set.contains(end)) { e--; } else { chars[s++] = end; chars[e--] = start; } } return String.valueOf(chars); } } ","date":"2022-04-16","objectID":"/double-pointer/:1:3","tags":["leetcode"],"title":"Double Pointer Algorithm","uri":"/double-pointer/"},{"categories":["algorithm"],"content":"Valid Palindrome 680. Valid Palindrome II (Easy) Problem Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome. Example Input: ‚Äúabca‚Äù Output: True Solution Double pointer is amazing! As long as the left and right ends of the pointer synchronous judgment, once the two Pointers point to different characters, then you can give a deletion of the opportunity, that is: the left to remove a character, continue to judge the rest; Or cut off a character on the right and judge the rest. class Solution { public boolean validPalindrome(String s) { for (int i = 0, j = s.length() - 1; i \u003c j; i++, j--) { if (s.charAt(i) != s.charAt(j)) { return check(i, j - 1, s) || check(i + 1, j, s); } } return true; } private boolean check(int min, int max, String s) { while (min \u003c max) { if (s.charAt(min++) != s.charAt(max--)) { return false; } } return true; } } ###Merge Array 88. Merge Sorted Array (Easy) Problem Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Example Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Solution Solved this in March. I was using double pointer algorithm at that time. But naive as I was trying to solve it from the head this time. Actually, it is possible that the merge will overwrite the values that have not been compared yet, so the correct way to do the comparison is to start from the back, and note that those zeros are reserved seats! class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { while (n \u003e= 1 \u0026\u0026 m \u003e= 1) { if (nums1[m - 1] \u003c nums2[n - 1]) { nums1[m + n - 1] = nums2[n - 1]; n--; } else { nums1[m + n - 1] = nums1[m - 1]; m--; } } if (m \u003c 1) { while (n \u003e= 1) { nums1[n - 1] = nums2[n - 1]; n--; } } } } ","date":"2022-04-16","objectID":"/double-pointer/:1:4","tags":["leetcode"],"title":"Double Pointer Algorithm","uri":"/double-pointer/"},{"categories":["algorithm"],"content":"Linkedlist Cycle 141. Linked List Cycle (Easy) Problem Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail‚Äôs next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ Solution At the beginning, I only thought of the data structure: just to traverse, store every Node and POS with HashMap, continue to see if the current Node can be found in the map. This should be a natural and intuitive idea. public class Solution { public boolean hasCycle(ListNode head) { Map\u003cListNode, Integer\u003e con = new HashMap\u003c\u003e(); if(head == null) { return false; } for(int pos = 0; head != null; head = head.next) { if(con.containsKey(head)) { return true; } con.put(head, pos++); } return false; } } If you use the double pointer algorithm, you can imagine the running race. There is often round running track. As long as there is a circle, as long as the time is unlimited, the fast runner will inevitably catch up with the slow runner. Therefore, the idea of the double pointer here is to set two fast and slow Nodes, the slow has one step, the fast has two steps. They will meet if there is a cycle. It is also known as Floyd‚Äôs Tortoise and Hare Algorithm. public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast!= null \u0026\u0026 fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { return true; } } return false; } } ","date":"2022-04-16","objectID":"/double-pointer/:1:5","tags":["leetcode"],"title":"Double Pointer Algorithm","uri":"/double-pointer/"},{"categories":["algorithm"],"content":"Longest through del 524. Longest Word in Dictionary through Deleting (Medium) Problem Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string. Example Input: s = ‚Äúabpcplea‚Äù, d = [‚Äúale‚Äù,‚Äúapple‚Äù,‚Äúmonkey‚Äù,‚Äúplea‚Äù] Output: ‚Äúapple‚Äù Solution Haven‚Äôt solved many Medium level problems. I was kind of lost at the beginning. This one is really hard. In fact, by switching ideas, this is a typical double pointer pattern (judging subsequence). The list can be sorted by a dictionary, or it is also possible to judge the lexicographical order when traversing the list. Thoughts are just two parts: 1. Traversing the list to find the most value (the longest and the minimum lexicographical order), this is to define an external variable out of loop. 2. Judging subsequence. This can be perfectly solved with double pointer, a bit similar to the KMP algorithm, but this is much simpler! class Solution { public String findLongestWord(String s, List\u003cString\u003e d) { String res = \"\"; for (String element : d) { if (isContain(element, s)) { if (element.length() \u003e res.length() || (element.length() == res.length() \u0026\u0026 element.compareTo(res) \u003c 0)) { res = element; } } } return res; } private boolean isContain(String child, String parent) { int i = 0; int j = 0; while (i \u003c child.length() \u0026\u0026 j \u003c parent.length()) { if (child.charAt(i) == parent.charAt(j)) { i++; } j++; } return i == child.length(); } } ","date":"2022-04-16","objectID":"/double-pointer/:1:6","tags":["leetcode"],"title":"Double Pointer Algorithm","uri":"/double-pointer/"},{"categories":null,"content":"Tianbo (Jake) LuTianbo Lu \"\rTianbo (Jake) Lu\r Tianbo Lu is currently pursuing a master‚Äôs degree in Computer Science with a concentration in Software Development \u0026 Applications at Virginia Tech. He has practical experience in web application development with solid backend skills and loves to learn new techniques and take ownership of his tasks to meet real-world challenges. He previously worked at Ningbo International Logistics Development Company Limited (NBGJWL) for 8 months as a Software Engineer, and had his Data Engineering internship in Summer 2022 at Teladoc Health. He will be graduated by May 2023 and is looking for a full-time new graduate/entry level position in Software/Data Engineering. He is located in Virginia and open to relocation. ","date":"2022-04-16","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]